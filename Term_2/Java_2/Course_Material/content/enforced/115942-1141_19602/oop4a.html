<!doctype html public "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Inheritance 2</title>
<script type="text/javascript" src="scripts/header.js"></script>
<link rel="stylesheet" type="text/css" href="css/prog.css">


</head>

<body onload='window.focus()'>
<h2>Inheritance 2</h2>
<h3>Topics Covered:</h3>
<ul>
<li>Casting Parent/Child Classes</li>
<li>The Object and Class Classes</li>
</ul>
<h3>Things To Do Before Reading This Section:</h3>
<ul>
<li>Read chapter&nbsp;11 in your textbook.</li>
<li>Have any homework ready for submission.</li>
</ul>
<h3>Things To Do After Reading This Section</h3>
<ul>
<li>Do any homework assigned by your professor.</li>
</ul>
<h3>Casting Parent/Child Classes</h3>
<p>After completing the Cylinder class, you'll notice that you probably still have some redundant code. The equals method, for example:</p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">public boolean equals(Cylinder c) { &nbsp;</span></p>
<p style="padding-left: 60px;"><span style="font-family: courier new,courier;">return (c.getRadius() == getRadius() &amp;&amp; &nbsp;&nbsp;&nbsp;c.getHeight() == this.height); </span></p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">} </span></p>
<p>Why should we write the code to compare the radius of the two objects when we've already written this code? Here we can also make use of the Circle's equals() method, but how? The Circle.equals() method requires a Circle object, but we're using a Cylinder!</p>
<p>When you're working with objects of different classes that are related via parent/child relationships, you can store references of one kind of object into a variable of a different object variable. For example, it is acceptable to use the statement:</p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">Circle roundShape = new Cylinder(1, 2); </span></p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">System.out.println(roundShape);</span></p>
<p>Try these statements: What is the output?</p>
<p>The roundShape object variable is defined to hold a reference to a Circle object, yet we are giving it a Cylinder object instead. Remember that this is an inheritance relationship, so a Cylinder "is a" Circle! Since Cylinder is actually a child class of Circle (in one way, still a Circle object but with some extra features), it is permissable to place a Cylinder object reference into a variable designed to hold a Circle reference. This is actually an implicit cast: You may freely place a child object reference into a variable defined to hold a parent object reference.</p>
<p>Does this work the other way? Try it:</p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">Cylinder can = new Circle(2); </span></p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">System.out.println(can);</span></p>
<p>What happens when you compile this code? Java will tell you that Cylinder and Circle are incompatible types. You may not implicitly cast down the hierarchy, from a parent object to a child object.</p>
<p>What happens if we modify the first example like this:</p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">Circle roundShape = new Cylinder(1, 2); </span></p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">System.out.println(roundShape); </span></p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">Cylinder can = roundShape; </span></p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">System.out.println(can);</span></p>
<p>If you compile this code, you'll get the same "incompatible types" error we had earlier. But shouldn't this type of cast be okay? After all, we are taking the object in roundShape, which was a Cylinder to begin with, and putting it into a new Cylinder variable called can! The problem is that the original Cylinder reference was stored in a Circle variable, and we can't take a Circle and put it into a Cylinder with an implicit cast. However, since the object was actually a Cylinder to begin with, we can use an explicit cast to place the reference of roundShape into the Cylinder can variable:</p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">Circle roundShape = new Cylinder(1, 2); </span></p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">System.out.println(roundShape); </span></p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">Cylinder can = (Cylinder)roundShape; </span></p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">System.out.println(can);</span></p>
<p>We've used explicit casts before, with primitive data types. You now know that you can also do this with object types.</p>
<p>This means that we can use the Circle's equals() method in our Cylinder.equals() method -- we can pass the parameter object into the parent equals() method:</p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">public boolean equals(Cylinder c) { &nbsp;</span></p>
<p style="padding-left: 60px;"><span style="font-family: courier new,courier;">return (super.equals(c) &amp;&amp; c.getHeight() == this.height); </span></p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">} </span></p>
<p>Now the method takes the parameter c (a Cylinder) and passes it to the Circle.equals() method. Circle.equals() compares the radius of the current object to the radius of the parameter and returns true (if they're the same radius) or false (if they're not equal). This result is used in a compound expression (AND) that also compares the heights of the two objects.</p>
<h4>Exercise</h4>
<p>In your test class, write a static method that takes a shape argument and displays information about it (its radius and height if applicable, its area and volume, if applicable). Writing this to display information for only a circle or only a cylinder would be easy, but how do we make it work for both shapes?</p>
<p>First of all, what type of parameter would this method require? Since a Circle variable can hold a reference to a circle or a cylinder, then our parameter should be a Circle. If it were a Cylinder, we wouldn't be able to pass Circles into the method:</p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">public static void displayShapeInfo(Circle shape) {</span></p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">}</span></p>
<p>Next, we need to find out what kind of shape the parameter really is; we can't use the getVolume() method if the shape is a Circle. For example, code the method this way, compile:</p>
<p style="padding-left: 30px;">public static void displayShapeInfo(Circle c) { &nbsp;</p>
<p style="padding-left: 60px;">System.out.println(c); &nbsp;</p>
<p style="padding-left: 60px;">System.out.println("Area: " + c.getArea()); &nbsp;</p>
<p style="padding-left: 60px;">System.out.println("Volume: " + c.getVolume());</p>
<p style="padding-left: 30px;">}</p>
<p>Compiling the test class with this method results in an error:</p>
<p style="padding-left: 30px;"><strong>TestShapes.java:41: cannot find symbol </strong></p>
<p style="padding-left: 30px;"><strong>symbol&nbsp; : method getVolume() </strong></p>
<p style="padding-left: 30px;"><strong>location: class Circle &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong></p>
<p style="padding-left: 60px;"><strong>System.out.println("Volume: " + c.getVolume()); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong></p>
<p style="padding-left: 30px;"><strong>^ 1 error</strong></p>
<p>This error should make sense, as there is no getVolume() method in the Circle class!</p>
<p>What we need to do is invoke the getVolume() method only if the shape is a Cylinder. How do we write code to ask "Is the shape a Circle or is the shape a Cylinder?" We can compare using the instanceof operator. Recall that this operator examines an object and determines what class it belongs to. We can test the shape parameter to see if it's a Circle or a Cylinder:</p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">public static void displayShapeInfo(Circle c) { &nbsp;</span></p>
<p style="padding-left: 60px;"><span style="font-family: courier new,courier;">System.out.println(c); &nbsp;</span></p>
<p style="padding-left: 60px;"><span style="font-family: courier new,courier;">System.out.println("Area: " + c.getArea()); &nbsp;</span></p>
<p style="padding-left: 60px;"><span style="font-family: courier new,courier;">if (c instanceof Cylinder) &nbsp;{ &nbsp;&nbsp;</span></p>
<p style="padding-left: 90px;"><span style="font-family: courier new,courier;">Cylinder temp = (Cylinder)c; &nbsp;&nbsp;</span></p>
<p style="padding-left: 90px;"><span style="font-family: courier new,courier;">System.out.println("Volume: " + temp.getVolume()); &nbsp;</span></p>
<p style="padding-left: 60px;"><span style="font-family: courier new,courier;">} </span></p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">}</span></p>
<h4>Dynamic Binding</h4>
<p>Why does a set of statements like</p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">Circle roundShape = new Cylinder(1, 2); </span></p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">System.out.println(roundShape);</span></p>
<p>actually work? When there is a method call, the JVM will look inside the current class for that method's definition. If the method isn't there, the JVM will go up the class hierarchy to the parent class and search there. If the method is not in the parent class, it will go up to that class's parent class, and so on, until it finds the method and executes it. In some cases, the JVM might go all the way up to a class called Object, which is the parent class of all classes in Java (even the ones you write!)</p>
<p>When the JVM goes through this process, it's called dynamic binding, and it's a part of the whole concept of polymorphism, which we'll examine in a later session.</p>
<h3>The Object and Class Classes</h3>
<p>You might recall from an earlier discussion that the equals() and toString() methods are already part of Java. We can now explore exactly where these methods come from. There is a class called Object (in the java.lang package, with classes like String and System) that is the parent class of every class in Java, including the classes you write yourself. This means that your Circle class's parent class is Object. Your shape class hierarchy looks like this:</p>
<p>Open the Java documentation and examine the Object class. You'll see a few methods, including equals() and toString(). You'll also see the finalize() method used to execute code when an object is destroyed (we explored this when we did garbage collection last term).</p>
<p>When we create a new class, we are actually extending the Object class, even though we don't actually type "extends Object" in our class header (some programmers do, but why bother with a waste of typing??). This also means that when you define an equals(), finalize(), and/or toString() method for your class, you're overriding the methods of the Object class!</p>
<p>Because of what we learned earlier about casting parent and child classes, this means you can do things like:</p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">Object o1 = new Circle(2); </span></p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">Object o2 = new Cylinder(3, 1); </span></p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">System.out.println(o1); </span></p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">System.out.println(o2);</span></p>
<p>Exercise</p>
<p><em>[uses arrays - skip this exercise if you haven't done arrays, yet]</em> Write a program that defines an Object array called shapes with 4 elements. Write the code to prompt the user to create four circles and cylinders (whichever they want - you'll have to ask them!) with user-specified values for radius and height (if applicable). Then loop through the array and display the shapes' information (including area and volume, where applicable).</p>
<p><em>[no arrays - do this question if you haven't done arrays in class (if you have no idea what I'm talking about, then do THIS question!)]</em>Write a program that defines four variables of type Object called obj1, obj2, obj3, and obj4. Write the code to prompt the user to create four circles and cylinders (whichever they want - you'll have to ask them!) with user-specified values for radius and height (if applicable). After getting all the information and instatiating the shapes to each of the four variables, use a method called displayShape() that takes an object and displays its information (including area and volume, where applicable).</p>
<p>&nbsp;</p>
<hr style="width: 100px;" width="100" />
<p>We can also clean up our toString() methods for these classes. In both classes, we're explicitly returning part of the string as "[class name]: radius=" + radius/getRadius(). We can use the Class class to clean this up. Examine the documentation of the Class class. There is a method called getName() that takes the current instance of the Class object and returns the name of the class the object belongs to. To use this, we have to get a Class instance for the object we want to use. For example, for an object called someShape (could be a Circle, could be a Cylinder, who knows?), we need to get its Class instance. Then we can find out information about it using methods from the Class class. We can use the Object.getClass() method to return a Class object, then invoke the getName() method:</p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">Object someShape = [circle or cylinder constructor]; </span></p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">Class shapeClass = someShape.getClass(); </span></p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">String className = shapeClass.getName();</span></p>
<p>Try this code in a test class, making someShape a Circle, then try it when someShape is a Cylinder.</p>
<p>You can write the above statements in one line if you prefer:</p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">String className = someShape.getClass().getName();</span></p>
<p>We can use this to clean up our toString methods. First, modify Circle's toString():</p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">// Circle's toString(): </span></p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">public String toString() { &nbsp;</span></p>
<p style="padding-left: 60px;"><span style="font-family: courier new,courier;">return this.getClass().getName() + ": radius=" + radius; </span></p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">} </span></p>
<p>This will display the class name with a colon in front of the radius information.</p>
<p>Next, update Cylinder. In Cylinder's toString(), we simply call the parent's toString() and then add the height information:</p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">// Cylinder's toString(): </span></p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">public String toString() { &nbsp;</span></p>
<p style="padding-left: 60px;"><span style="font-family: courier new,courier;">return super.toString() + "&nbsp;&nbsp;&nbsp; height=" + height; </span></p>
<p style="padding-left: 30px;"><span style="font-family: courier new,courier;">} </span></p>
<p>Recompile both classes, then run your previous exercise program again and make sure the output is the same.</p>
<h4>Exercises</h4>
<ol>
<li>Modify your Sphere class from the last session to take into account the changes we've made to the Circle class. For example, the toString() and equals() methods - what needs to be changed?</li>
<li>Modify your [array] exercise from earlier so that the user can also create Sphere objects. How much code did you have to change? Did you see any areas where you could have originally written the code differently so that it was easier to modify?</li>
</ol>
</body>
</html>