<!doctype html public "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Random Access Files</title>
<script type="text/javascript" src="scripts/header.js"></script>
<link rel="stylesheet" type="text/css" href="css/prog.css">

<script type="text/javascript">
<!--
var q1 = "If the first index is 0 and the last index is 10, then the array has a length of 11 (the array has 11 elements).";
//-->
</script>

</head>

<body onload='window.focus()'>

<h2>Random Access Files</h2>

<h3>Topics Covered:</h3>

<ul class="outer">
	<li><a href="#random">Random Access Files</a>
	<li><a href="#class">The RandomAccessFile Class</a>
	<li><a href="#write">Writing to a Random File</a>
	<li><a href="#read">Reading From a Random File</a>
</ul>

<h3>Things To Do Before Class</h3>
<ul class="outer">
	<!--<li><a href="files/randomFiles09.zip">Download this zipped Java code</a>.-->
	<li>Read chapter 19.7 and 19.8 in your textbook.
	<li>Read the <a href="http://java.sun.com/docs/books/tutorial/essential/io/rafs.html">Random Access Files</a> page at java.sun.com.
</ul>

<h3>Things To Do After Class</h3>
<ul class="outer">
	<li>Finish the exercise at the end of these notes.
</ul>

<a name="random"><h3>Random Access Files</h3></a>

<p>There are different kinds of files you can use for storing data in as records and fields.  So far, you've worked with <b>sequential files</b>.  With a sequential file, records must be accessed sequentially in order.  For example, records are written to the file in the order that the user adds them, and records are read from the file in the order they were written.  If you want to access a record in the file, you must start at the beginning of the file and read each record until you get to the one you want:</p>

<pre>// gets record 5 from some unknown number of records
try {
    Scanner fileIn = new Scanner(new File("file.dat"));
    fileIn.useDelmiter(System.getProperty("line.separator"));
    int recCounter = 0;		// counter for records
    // read until you find record 5 or reach eof
    while ((recCounter &lt; 5) || (fileIn.hasNext())) {
        // read a record
        String record = fileIn.next();
        System.out.println(record);
        recCounter++;
    }
} catch (IOException ex) {
	System.out.println(ex);
}</pre>

<p>Sequential files are a lot like cassette tapes of music.  If you want to listen to the 5th song on a tape, you have to start at the beginning of the tape and fast-forward past the first four songs to get to the fifth song.</p>

<p>When you're working with large files, this process can be very tedious!  In addition, deleting record or editing/modifying existing records can be very cumbersome.  For example, to edit a record you would need to find the record you want to edit, bring it into your interface, wait for the user to make the changes, and then somehow write the new version of the record back into its original spot.  In a sequential file, this is difficult:  what if the user added extra characters to a string field?  In that case, the record no longer fits into its original spot!  You'd have to create a new file, copy over all the unchanged records above the edited one, then write the newly changed record, then copy over the rest of the unchanged records.  Again, with a large file, this could take up a lot of processing time!</p>

<p>Random access files solve these problems.  Random files are a lot like a CD of music:  If you want to listen to song #5, you simply "seek" or move to that particular song on the CD by pressing a button a few times or, on some players, typing the track number.  This is quick and easy compared to searching sequentially as you would on a cassette!</p>

<p>The key to random files functioning this way is in their records.  Each record in a sequential file is variable length; in other words, each record is a different number of bytes in length, depending on what data the record contains.  In a random file, all records are of a fixed length.  This means that the programmer decides ahead of time how long each record is going to be by defining each field's data type and size.  For example, if you were going to store information about your CD collection, you might decide on some of the following fields:</p>

<table border=1 cellpadding=2 cellspacing=0>
<tr><td colspan=3><b>File Name:</b> cds.dat</td></tr>
<tr><th>Field Description</th><th>Data Type</th><th>Size</th></tr>
<tr><td>Cd Title</td><td>String</td><td>35</td></tr>
<tr><td>Cd Artist</td><td>String</td><td>35</td></tr>
<tr><td>Number of Songs</td><td>int</td><td>n/a</td></tr>
<tr><td>Cd Cost</td><td>double</td><td>n/a</td></tr>
</table>

<p>In the <b>file description</b> shown above, there are 4 fields.  The first two fields are strings and are each 35 characters in length.  In this file, you may not store the title or artist in more than 35 characters!  This means that as a programmer, you have to make some serious decisions about your file data.  Make sure you leave an adequate amount of space for all possible kinds of values.  This doesn't mean you can make all your string fields huge "just in case"!  You also want to make sure that you don't waste space!</p>

<p>What happens if a string field's value is less than 35 characters?  Your program must make sure that each field is <i>exactly</i> 35 characters, so you will need to pad fields with spaces so that it is exactly 35 characters!  This is a normal part of using random files, and in fact, if you're printing reports with your data, you will find that having the extra padding cuts down on the amount of code you would have to write to format your data into nice columns!  If you don't want the extra spaces in your data (for example, if you're performing a search or if you're displaying the data in text fields for editing) you'll want to trim off the excess spacing (e.g. stringVariable.trim()).</p>

<p>What about the integer and double fields in our file description?  They have "n/a" (not applicable) in the Size column of the table.  This is because primitive data types are already of fixed length.  You might remember this information from when you first learned about primitive data types.  If you don't remember the number of bytes for the diffent kinds of primitive types, check the Java Reference under Course Tools for the Primitive Types page.  Clicking on each data type will give you the number of bits or bytes of space each one requires.</p>

<p>In our CDs example, we can calculate the size of each record of our file by adding up all the field sizes.  A string field requires two bytes of space for each character, so for the title field, which is 35 characters, 70 bytes of space is required.  For the artist field, we  also require 70 bytes because it is also 35 characters.  From your reference material, you probably found that an integer field requires 4 bytes and a double 8 bytes.  Therefore, each record in our file is 70 + 70 + 4 + 8 = 152 bytes long.</p>

<p>Knowing the size of a record in a random file is important for finding out where records are located.  For example:</p>

<ol>
	<li>If your CD file is 15,200 bytes long, how many records are in the file?
	<li>At what position is record #5?
</ol>

<p>Answering these questions is easy!  If your file is 15,200 bytes long, and each record is 152 bytes, then obviously you must have 15200/152 = 100 records in your file!</p>

<p>Answering the second question is also simple:  If each record is 152 bytes, then the first 152 bytes (byte numbers 0 to 151) of the file is the first record, the second 152 bytes (byte numbers 152 to 303) is the second record, the third 152 bytes (byte numbers 304 to 455) is the third record, etc.  To find out the location of record number <i>n</i> in a file with a record length of <i>r</i>, you use the formula</p>

<pre>(n-1)*r</pre>

<p>So to find the location of record #5 in our CD file, we would go to byte (5-1)*152 = 4*152 = 608.</p>

<p>Another great thing about random files is that because you are storing the numeric data as primitives, the files will end up being smaller.  In a sequential file, everything was stored as a String.  Variable-length strings take up even more space than fixed length strings, so numbers that are stored as strings take up way more space than a number stored as an integer as a double.</p>

<p>Finally, with a random file, you can use a single stream to read and write data.  Sequential files required that you open up one stream for output and one stream for input, and you had to make sure to close one stream before opening the other.  With a random file, you use one stream, and the data can travel through the stream in both directions.</p>

<p>In summary, there are 3 main advantages to random files:</p>

<ol>
	<li>Random files allow you to directly access any record.
	<li>Random files are smaller.
	<li>Random file streams can move data in both directions.
</ol>

<h4>Exercises</h4>

<p><b>1. </b>
For each of the following file descriptions, indicate:<br>
i) How many bytes does each record require?<br>
ii) What would be the address of the 5th record?<br>
iii)  If there were 15 records, how many total bytes would the file contain?
</p>

<p><b>a.</b>
<table border=1 cellpadding=2 cellspacing=0>
<tr><td colspan=3><b>File Name:</b> inventory.dat</td></tr>
<tr><th>Field Description</th><th>Data Type</th><th>Size</th></tr>
<tr><td>Product ID</td><td>String</td><td>10</td></tr>
<tr><td>Product Description</td><td>String</td><td>100</td></tr>
<tr><td>Unit Price</td><td>double</td><td>n/a</td></tr>
<tr><td>Re-Order Point</td><td>int</td><td>n/a</td></tr>
</table>
</p>

<p><b>b.</b>
<table border=1 cellpadding=2 cellspacing=0>
<tr><td colspan=3><b>File Name:</b> rentals.dat</td></tr>
<tr><th>Field Description</th><th>Data Type</th><th>Size</th></tr>
<tr><td>Item ISBN</td><td>int</td><td>13</td></tr>
<tr><td>Item Name</td><td>String</td><td>100</td></tr>
<tr><td>Replacement Cost</td><td>double</td><td>n/a</td></tr>
<tr><td>Copy Number</td><td>int</td><td>n/a</td></tr>
<tr><td>Out</td><td>boolean</td><td>n/a</td></tr>
</table>
</p>

<p><b>2.</b> A program requires a data file to keep track of Customers.  Programs will need to access a customer's first and last name, the customer id, and the customer's outstanding balance.<br>
<b>a.</b> Design a file description for this data file.<br>
<b>b.</b> How many bytes does each record of your file require?
</p>

<a name="class"><h3>The RandomAccessFile Class</h3></a>

<p>The RandomAccessFile class is fairly simple to use.  You should check the documentation to get an overview of the different methods it has available, although we will go over some of the basic ones in these notes.  The RandomAccessFile constructors allow you to open a stream to a random access file (using a String for the file specification, or a File object) in either "read-only" mode, or "read-write" mode.  If you are going to allow the writing and read of records to and from the file, you will want to use "read-write" mode.  If you are only using the data file for reading and displaying records, use "read-only" mode.  To instantiate a random access file stream for read-write mode, for example, you might have code such as:</p>

<pre>File f = new File("cds.dat");
RandomAccessFile raf = new RandomAccessFile(f, "rw");</pre>

<p>When instantiating your random access file stream, use the mode "rw" for read-write and "r" for read-only.</p>

<p>The constructors throw a couple of unchecked exceptions, but also throw a FileNotFoundException if you open a file for reading that doesn't exist.  You can open a file for read-write access that doesn't exist, as you might want to create a new file.</p>

<p>Figure 19.16 on page 640 of your textbook shows a list of some of the methods in the RandomAccessFile class.  As you'll see in a moment, the first two listed, seek() and getFilePointer(), are vital in working with random files.  The key to accessing and writing records is knowing at what byte a particular record starts and ends.  Random access file objects have a record pointer that is always pointing at a particular byte in the file.  You will have to move that record pointer to the beginning of a record in order to start reading that record's data.  The seek() method will move that record pointer to a byte number that you specify.  The getFilePointer() method will return the pointer's current byte position in the file.  We'll use these methods a lot as we read and write records to the file.</p>


<a name="write"><h3>Writing to a Random File</h3></a>

<p>To write data to a random file, you can use a variety of methods, depending on the data type of the field you are writing:</p>

<ul class="outer">
	<li>writeInt(int value) - writes the integer value to the file.
	<li>writeDouble(double value) - writes the double value to the file.
	<li>writeChars(String value) - writes the string value to the file as a set of 2-byte characters.
	<li>writeChar(char value) - writes a single character value to the file.
	<li>writeBoolean(boolean value) - writes the true or false boolean value to the file (booleans take require byte).
</ul>

<p>All of these methods throw an IOException if some kind of error occurs accessing the file.  There are additional methods and you should check the documentation if you are interested in those.</p>

<p>One of the advantages of random files is that data is stored in byte format.  This makes fields that contain data types such as integer and double much smaller!  It means however, that we have to write the data as the right data type.  To store an integer value in the file, you need to use the writeInt() method, for example.</p>

<a name="firstEx"></a>
<h4>Exercise</h4>

<p>Write a simple console program that tries out the RandomAccessFile stream.  Your program should have the following statements:</p>

<ol>
	<li>Open a random access file stream that reads and writes to the file "file.dat".
	<li>Create a string variable called myString and give it a sentence of your choice.
	<li>Write the following values to your random file:
		<ul class="inner">
		<li>The string variable.
		<li>The integer value 10.
		<li>The double value 123.45.
		</ul>
	<li>Display any exceptions to the console.
</ol>

<p>Once you've compiled and run your program, stop the program and then go to a Command Prompt window.  Browse to the directory where your application is stored and locate the "file.dat" file.

<ol>
	<li>Look at your code:  how many bytes should your file be, based on the data you wrote to it?
	<li>Do a "dir" command.  How many bytes are actuall in your file?
	<li>Type the command <font face="Courier New"><b>type file.dat</b></font>.  What do you see?
	<li>Type the command <font face="Courier New"><b>debug file.dat</b></font>.  When you see a "-", type "d" then press Enter.  You should see something similar to this (my string was "This is a string field.":

	<pre>D:\Courses\winter05\PROG24~1\week10>debug file.dat
-d
13B2:0100  00 54 00 68 00 69 00 73-00 20 00 69 00 73 00 20   .T.h.i.s. .i.s.
13B2:0110  00 61 00 20 00 73 00 74-00 72 00 69 00 6E 00 67   .a. .s.t.r.i.n.g
13B2:0120  00 20 00 66 00 69 00 65-00 6C 00 64 00 2E 00 00   . .f.i.e.l.d....
13B2:0130  00 0A 40 5E DC CC CC CC-CC CD 00 20 00 20 00 20   ..@^....... . .
13B2:0140  00 20 00 20 00 20 40 33-F3 33 33 33 33 33 00 00   . . . @3.33333..
13B2:0150  00 05 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
13B2:0160  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
13B2:0170  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
-q

D:\Courses\winter05\PROG24~1\week10></pre>

You can see some of your data in the last column.  The first column is memory addresses and the big column in the middle is the hex values for the data in the file (this is showing your file loaded into memory).  In my example, the first two bytes in my middle column 00 54) represent the ".T" you see in the third column.  This is the first character stored in my file.  See if you can find the last character of your string.  What four bytes appear after your last character?  You should see the bytes "00 00 00 0A" after the last character of your string (in mine, it's at the beginning of the fourth row).  What is the decimal value of the hex digit 'A'?  Where does this come from?<p>

To get out of the debug command, type "q" and press Enter.
</ol>

<p>Why did your output from the "debug" command look different from mine?  There are lots of reasons, other than the obvious answer that your string field was probably different from mine.  In addition, your computer most likely loaded your file into a different spot in memory, so the first column of memory addresses would have been different.  Lastly, the "d" command performs a memory dump of a 128-byte block of memory.  Your file probably wasn't 128 bytes long (mine was only 58) so all the bytes displayed that are after your file data are just whatever crap was in that part of memory.  This could be leftover data or bits of file from some previous program, or it might have been empty.  Either way, your display won't look exactly like mine or anyone else's.  As long as you were able to see your string field and find the integer value 10 in the second field, don't worry.  If you weren't able to find these things, check with your instructor.</p>

<h4>Record Offset</h4>

<p>An important part of working with random files is the record offset.  The record offset is a special pointer or position in the file.  For example, add the following statement after each of your write statements in the previous program (in the example, raf is the random access file stream object):</p>

<pre>System.out.println(raf.getFilePointer());</pre>

<p>Delete the file.dat file, then compile and run your program again.</p>

<p>What are the 3 numbers displayed on the console when you run the program?  Mine were (yours might not be exactly the same):

<pre>46
50
58

Press any key to continue...</pre>

<p>The first number is the record offset after writing the string field.  In my program, the string field is "This is a string field." which is 23 characters.  This means that it takes 46 bytes.  The first number displayed on my console was 46.  After writing the string field, the record offset was sitting at position 46, so when the result of raf.getFilePointer() was displayed, it displayed 46.</p>

<p>After writing the integer field, which was 4 bytes, the pointer was left at position 50.  That makes sense:  it was at 46 before, then wrote 4 bytes and ended up at position 50.  Lastly, the program wrote the 8-byte double value and the pointer was left at position 58.</p>

<p>The record pointer will move along as you write each field to the file.  We'll also see later that you can move the pointer around when you want to read data from the file.</p>

<h4>Prepping String Fields</h4>

<p>When accessing records in a random file, you know that each record is the same size.  This is what allows you calculate the position of a record so that you can retrieve it.  For primitive types like ints, doubles, chars, and booleans, it's simple to ensure that each record is the exact same size.  However, Strings are objects and their size is variable.  In fact, we don't actually write Strings to a random file.  Strings are written as a series of individual characters using the writeChars() method.</p>

<p>In order to ensure that each record is the same size, we have to make sure that String fields are of a fixed size.  When you design a file, you indicate how many characters a String field will require.  You must make sure that all String fields saved to a random file fit into this dimension.  For example, if a customer ID field is said to have 10 characters, then you must store it in exactly 10 characters.  If the field value is too big, it must be truncated.  If the field value is too small, extra spaces are added to it (padding) to ensure that it's exactly the right size.</p>

<p>Part of saving String fields to a random file involves preparing the string field to be written as the correct size:</p>

<pre>Define a constant SIZE as the number of characters required
Read in a string value
If length-of-string > SIZE
     Truncate the string value to SIZE characters
Else If length-of-string < SIZE
     Add length-of-string - SIZE spaces to the string value
End If
Write string value to file</pre>

<p>Notice the if statement - we only have actions if the string's length is too big or too small.  We don't need to do anything if the string happens to already be the correct size.</p>

<p>In Java code, performing these two actions are simple.  Truncating a string can be done using the substring() method.  For example:</p>

<pre>customerID = customerID.substring(0, ID_SIZE);</pre>

<p>Padding the string with extra spaces is also simple.  We can use a for-loop:</p>

<pre>int numSpaces = ID_SIZE - customerID.length();
for (int i=1; i&lt;=numSpaces; i++)
     customerID += " ";		// you can use StringBuffer if preferred</pre>

<p>Note that we use a separate variable for the number of spaces to add.  You can't count using customerID.length() in the loop condition, because length()'s return value will be different each time you add a space to the string!</p>

<p>Since this is such a common task when working with random files, you'll likely want to place this code in a method. The method can accept the string value to prep and the size of the field, and return the altered string:</p>

<pre>method prepStringField(string value, size)
     If length-of-string > SIZE
          Truncate the string value to SIZE characters
     Else If length-of-string < SIZE
          Add length-of-string - SIZE spaces to the string value
     End If
	 Return string value
End method</pre>

<h4>Exercise</h4>

<a name="consoleEx"></a>

<p>Write a console program that adds records to a data file that keeps track of
an inventory of books/movies/whatever.  The file description
is shown below:</p>

<table border=1 cellpadding=2 cellspacing=0>
<tr><td colspan=4><b>File Name:</b> media.dat</td></tr>
<tr><th>Field Description</th><th>Data Type</th><th>Size</th></tr>
<tr><td>Title</td><td>String</td><td>35</td></tr>
<tr><td>Number of Copies</td><td>int</td><td>n/a</td></tr>
<tr><td>Price</td><td>double</td><td>n/a</td></tr>
</table>

<p>Write the code that prompts the user to enter records that will be
stored in the file.  After saving a set of records, display the total
number of records in the file.  Consider the following points:</p>
<ul class="outer">
<li>You will need constants for the size of the fields (int), and the
size of a record (long).
<li>Each string field will need to be prepped - either truncated or padded
with spaces.
<li>There might already be records in your data file, so be sure to move
to the end of the file before you save.
<li>Use whatever method you prefer to continue adding records.  An example
is shown in the sample output below.
</ul>

<p><b>Sample Output</b> (2 records already in file, 3 new records added)</p>

<pre>Adding New Media

Enter Title: Shipping News
Enter # of Copies: 3
Enter Price: 9.99
Do you want to add another? (Y/N) y

Enter Title: The Corporation
Enter # of Copies: 5
Enter Price: 19.99
Do you want to add another? (Y/N) Y

Enter Title: Rabbit Proof Fence
Enter # of Copies: 7
Enter Price: 22.99
Do you want to add another? (Y/N) n

Total Records in File: 5

Press any key to continue...</pre>

<a name="read"><h3>Reading from a Random File</h3></a>

<p>Naturally, once you have a data file, you'll want to
read that data into a program.  Recall that with the
RandomAccessFile stream, data can travel in both directions,
so you don't have to do anything extra if you've already opened the stream for writing to the file.</p>

<p>You can use a variety of methods to read from the file, 
    depending on what kind of data you are reading.
    For example, readChar() will read and return a single
    2-byte character from the file.  readInt() and
    readDouble() will read and return integer and double
    values.  You will need to know what the structure of
    each record is in order to correctly read the data
    from the file.  For example, if the first 60 bytes
    are part of a string field and the next 8 bytes are
    a double, you'll have to make sure to perform
    readChar() 30 times and then perform a readDouble().</p>

<p>Reading strings from the file is the most involved,
    but not difficult.  A string is a series of characters,
    and since there is no readString() method, you might
    want to design your own readString() that makes use
    of the readChar() method.  If you are reading a
    30-character string from the file, you will need to
    perform readChar() 30 times and concatenate all the
    characters to a String:</p>

<pre>public static String readString(java.io.RandomAccessFile raf, int size) 
							throws java.io.IOException {
	String n = "";
	for (int i=0; i&lt;size; i++) 
		n += String.valueOf(raf.readChar());
	return n;
}</pre>

<p>This method takes a random access file stream and the 
    size (number of characters) of the string field to
    read.  The loop reads one 2-byte character from the
    file and concatenates that character to the string n.
    The loop should execute as many times as the value in
    size; for example, if the size of the field is 30
    characters, then the loop executes 30 times to read
    in 30 characters.  At the end of the method, the
    string is returned.</p>


<!--
<h4>Exercise</h4>

<p>In the <a href="#firstEx">first exercise</a>, add the 
    code to read and display the string field, the value
    10, and the value 123.45.</p>
-->

<p>It is interesting to note that any trailing spaces that
    were added as
padding to make this a fixed-length string at the time of
writing the file
are included in the returned string.  This can be helpful
if you are
printing a report with the field values in rows and columns,
but if the
trailing spaces are undesirable, you can use the String
class's trim()
method to get rid of the spaces.</p>

<!--
<p>To see the effect of this, write some code to read and display the first
record saved in the <a href="#consoleEx">console exercise</a> from the
previous session.  Display the three values (first name, last name, contact
info) on a single line, separated by commas.</p>

<pre>Sample File Data:
Kaluha                                            ,The Cat
                                  ,cat@kitty.on.ca</pre>
-->

<p>To see the effect of this, you can try loading your data file into a text
editor.  You'll see a lot of junk on the screen - don't worry.</p>

<p>You'll notice that there are spaces between character data, and probably
large amounts of spaces between string fields and other fields.  This is
normal, since each character is 2 bytes, and you added extra padding to the
string field to ensure it was the right size.</p>

<p>In some cases, when displaying field values in rows and columns,
the spaces can actually be of help when lining up the fields.  However
if you are going to be displaying field values formatted with other
field values, or in GUI components like text boxes and labels, you will
want to trim off the extra spaces.  This is easily done using the
String.trim() method:</p>

<pre>public static String readString(java.io.RandomAccessFile raf, int size) 
							throws java.io.IOException {
	String n = "";
	for (int i=0; i&lt;size; i++) 
		n += String.valueOf(raf.readChar());
	return n.trim();
}</pre>

<p>An even better idea is to modify your method to include a
boolean value - true to trim, false to leave the spaces alone.
You can then use an if statment and trim the value before it's returned,
if the boolean parameter is true.</p>

<h4>Finding the Right Record</h4>

<p>Before you can read the data from the file, you have to also make sure you are reading the right record.  If you want to read the fifth record, you'll have to move the record offset to the spot where the fifth record begins.  If you want to start at the beginning of the file, you'll have to position the record offset to the first byte.</p>

<p>We can postion the record offset or file pointer using the seek() method.  For example:</p>

<pre>// go to beginning of file
randomFile.seek(0);
// go to end of file
randomFile.seek(randomFile.length());
// go to record n
randomFile.seek(RECORD_SIZE * (n - 1));</pre>

<h4>Exercise</h4>
<p>1.  Write the statements that would find and read in the last record in the file.<br>
2.  What if a file had no records at all?  How would you modify the statements in #1?</p>

<h4>Exercise</h4>
<p>Modify your <a href="#consoleEx">previous exercise with the media records</a>
    to display records in with this format:</p>
<pre>nn of Title @ $pp.pp</pre>
<p>(where nn is the number of copies, Title is the title field value,
and $pp.pp is the formatted price)</p>

<p>If you see large gaps between your title and the @ $pp.pp,
    you forgot to trim() your string value from the file!</p>

<!--
<h4>Exercise</h4>

<p><b>For Console:</b> For students who know how to work with console
I/O, but not GUI interfaces.</p>

<p>Write a program that reads and displays all the records in the
media.dat file.  Display each record in the form:</p>
<pre>title 			contactInfo</pre>

<p>After all the records have been read, output the number of records in
the file.</p>

<hr>

<p><b>For Swing GUI:</b> Option for students who know how to work with Swing interfaces.</p>
-->
<h4>Practice Exercise</h4>

<p>Create a GUI program that allows the user to add and review
    records from the media file:</p>

<p><img src="images/randomFileExGui.png"
        alt="screen shot - PNG file, email me if you can't see the image here!" /></p>

<p>You need to perform the following tasks:</p>

<p><b>1. </b> Create special data members</p>
<ul class="outer">
    <li>add a public constant TITLE_SIZE to the program
            <ul class="inner"><li>how many characters is
                the title field?</li>
            </ul>
    <li>add a public constant RECORD_SIZE to the program
	<ul class="inner"><li>how many bytes is a record
                in this file?</ul>
    <li>add a private instance variable for your
        RandomAccessFile object
        <ul class="inner"><li>this needs to be declared
            only, not initialized to anything, yet</li>
        </ul>
</ul>

<p><b>2.  </b> In the constructor, open up the random access
    file stream to the "media.dat" file.
    Any errors that occur should have
error messages appear in JOptionPane dialogs.</p>

<p><b>3. </b> Write the code for the event handler:</p>

<p><b>b. </b> For the Save button, check each field and,
if a field is empty, display a user-friendly error message
and ask the user to fill in that field (set the focus to
the empty field).  Otherwise, pad the title field with
enough spaces to make it 35 characters, then write all
three fields to the file.  Clear the text boxes and set
the focus to the title field so that the user can start
adding a new record.  For any exceptions that occur,
display user-friendly messages using JOptionPane dialogs.</p>

<p><b>c. </b> For the Display All button, you'll  need to
    display all the records in the file.  You'll need to
    calculate the number of records in the file and save to
    a variable, then "seek" to the beginning of file.  Once
    at the beginning of the file, use a loop (a for-loop will
    work)  to read each record fromthe file and display it
    in the text area.</p>

<p><b>d. </b> The Get Record button asks the user to enter a specific
        record number.  If they entered a valid number, get that
        record from the file and display it in the text fields.</p>

<p><b>Extra Stuff:</b>
<ul class="outer">
    <li>If the user retrieves a record, they may wish to edit it.
    How would you code this?  The edited record has to be saved
    in the same location in the file where it came from...</li>
</ul>

<script type="text/javascript" src="../scripts/copynote.js"></script>

</body>
</html>
