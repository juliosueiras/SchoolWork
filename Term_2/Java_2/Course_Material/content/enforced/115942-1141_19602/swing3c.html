<!doctype html public "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Other Types of Events</title>
<script type="text/javascript" src="scripts/header.js"></script>
<link rel="stylesheet" type="text/css" href="css/prog.css">


</head>

<body onload='window.focus()'>

<h2>Other Types of Events</h2>

<h3>Topics Covered:</h3>

<ul class="outer">
	<li><a href="#key">Writing KeyEvent Handlers</a>
	<li><a href="#mouse">Handling Mouse Events</a>
	<li><a href="#adapt">Using Adapter Classes</a>
</ul>

<h3>Things To Do Before Class</h3>
<ul class="outer">
	
	<li>Things to browse from Books24x7:
		<ul class="inner">
		<li>Definitive Guide to Swing for Java 2, Second Edition by John Zukowski; ISBN:189311578x -- Chapter 2 (Event Handling with the Swing Component Set)
		<li>Pure JFC Swing by Satyaraj Pantham; ISBN:0672314231 -- Chapter 8 (Buttons and CheckBoxes)
	</ul>
	<li>Read the following tutorials from Sun: 
		<ul class="inner">
		<li><a href="http://java.sun.com/docs/books/tutorial/uiswing/events/generalrules.html" target="_new">General Information about Writing Event Listeners</a>
		<li><a href="http://java.sun.com/docs/books/tutorial/uiswing/events/keylistener.html">How to Write a Key Listener</a>
		<li><a href="http://java.sun.com/docs/books/tutorial/uiswing/events/mouselistener.html" target="_new">How to Write a Mouse Listener</a>
		<li><a href="http://java.sun.com/docs/books/tutorial/uiswing/events/mousemotionlistener.html" target="_new">How to Write a Mouse-Motion Listener</a>

	</ul>
</ul>

<h3>Things To Do After Class</h3>
<ul class="outer">
	<li>Do any homework assigned by your professor.
</ul>


<a name="key"><h3>Writing KeyEvent Handlers</h3></a>

<p>A key event handler deals with keyboard events.  For example, a series of events occur when
    the user types a key in a component that is registered with a key listener.  This is
    useful when you want to control the types of key values that are allowed in a text field.
    The KeyListener interface includes the following methods used for handling key events:</p>

<ul class="outer">
	<li><b>keyPressed(KeyEvent k)</b> - this event occurs when a key is pressed down
            while a component has the focus.  This event is generated for any key,
            even keys like page-up, shift, and the function keys (keys that don't
            have Unicode representation).  This event can be tricky to work with because
            they depend on the keyboard layout, which varies from platform to platform.
	<li><b>keyReleased(KeyEvent k)</b> - this event occurs when the key is released
            while a component has the focus.  Like keyPressed(), this event will be generated
            even for keys that do not have a Unicode representation, and depends on the platform's
            keyboard layout.
	<li><b>keyTyped(KeyEvent k)</b> - this event occurs after the user types a key
            that can be represented as a Unicode character.  This means you can
            only use this event when concerned with letters, numbers and symbols.
            Keys such as page-up, shift, and function keys don't generate a
            keyTyped() event.  keyTyped() does not concern itself with keyboard layout, so
            it's your best choice when working on programs that will run on multiple platforms.
</ul>

<div class="puzzle">People often have trouble differentiating between the 
keyPressed()/keyReleased() and keyTyped() events.<br />
Think about how you use a keyboard: Sometimes you make a character appear
by pressing it's key, such as the letter "j".  Sometimes you make a character
appear by pressing two or more keys such as "J" (Shift-j) or "&ccedil;" 
(holding the Alt key while pressing 1, 3, and 5 on the number keypad).
When programming for keyboard events, there is a difference between the
characters that the user types and the keys that the user presses.  Not
all of the keys on a user's keyboard will generate a character on the screen.
The keyPressed() event can be used to detect when keys with no Unicode 
representation are pressed, such as the Shift key.  The keyReleased() event
can be used to detect when a key is released (for example, after the user releases
the Alt key when they've finished typing numbers on the numeric keypad).
The keyTyped() event can be used when you just want to detect if a certain
character was typed (for example, did they type "j" or "J"?).</div>

<p>Each of these events contains a KeyEvent parameter, which contains the key event object 
    that was fired by a registered component.  The KeyEvent object contains some useful
    information.  It contains a large number of constant fields for various key values,
    and it also has a getKeyChar() method that returns a character value of the character that
    was entered (if the only pressed a key that has no Unicode value, then this method
    returns KeyEvent.CHAR_UNDEFINED).  
    There is also a getKeyCode() method that returns the ascii value of the
    key the user pressed, but this this information is only available in the keyPressed() and
    keyReleased() methods.  If you use this method in the keyTyped() event, it will
    return KeyEvent.CHAR_UNDEFINED.</p>

<p>In the keyTyped() method, you can also use the <b>setKeyChar()</b> method to change the key
    that the user pressed.  This is helpful if you want to discard certain keys (use
    setKeyChar('\0') to set the key typed to a null value) that are typed by the user.
    You will most likely use the keyTyped() event method for simple programs that do things
    like data validation in text fields.</p>

<p>Note that key events are processed before the character typed
actually appears in the text field.  So when a key event for a registered
text field executes for a character typed, that character is
not actually included in the text field's value (via getText()).
For example, if my txtBox's value is "ab" and then the user types
"c" adn the keyTyped() event is triggered, txtBox.getText() will
still return "ab" during the keyTyped() event, not "abc".
If you need to be able to access a registered text field's value in full
as the user is typing, use a 
<a href="http://docs.oracle.com/javase/tutorial/uiswing/events/documentlistener.html">DocumentListener</a>.</p>

<p>To register a component with the key listener, you use the <b>addKeyListener()</b> method.
    Usually you will register text fields with the key listener, but there are other
    components that can fire key events also.</p>

<h4>Exercise</h4>

<p>Design the following interface:</p>

<p><img src="images/sess4-2_key.jpg"></p>

<p>As we did with ActionListener, you can make the interface it's own key listener
    by implementing the KeyListener interface.  You can also implement the ActionListener
    interface so you can make the buttons work, also.  Just separate the interfaces
    with a comma:</p>

<pre>public class KeyExercise extends JFrame implements ActionListener, KeyListener</pre>

<p>The addKeyListener(Object) method registers a component with whatever object is
    the key listener, so you should register the two text fields with "this".  They
    KeyListener interface has the three methods we mentioned earlier, so you have to
    include them all, even if you aren't using them:</p>

<pre>public class KeyExercise extends JFrame implements ActionListener, KeyListener
{
	...
	public void keyTyped(KeyEvent k)
	{
		// we'll put code here
	}
	
	// we aren't using these, but they must be included:
	public void keyPressed(KeyEvent k){}
	public void keyReleased(KeyEvent k){}
}</pre>

<p>In the keyTyped() event method, use the JOptionPane's showMessageDialog() method to display
    the result of the KeyEvent parameter's getKeyChar() method.</p>

<p>When you get that working, try displaying this, instead:</p>
<pre>"Ascii: " + (int)k.getKeyChar()</pre>

<p>Now try writing the event handler code to discard any value that isn't a letter.</p>

<p>When you get this working, what happens when you use the (.) decimal/period?  
    Write one if-statement that throws away any
    value that isn't a digit or decimal point.</p>

<div class="highlight">What happens if the user tries to type more than one decimal?
Well, you'll have to add the code that keeps track of whether or not the user typed
a decimal point.  If there's a decimal point already in the text field, ignore any
other decimals.  Be careful, because the user could type a decimal point, and then
delete it and add it again later!</div>

<a name="mouse"><h3>Handling Mouse Events</h3></a>

<p>Another type of event you can handle in a program is a mouse event.
    Actually, mouse events in Java are divided into two different
    listener classes:  MouseListener and MouseMotionListener.
    Each class has a set of event methods as described below:</p>

<ul class="outer">
	<li><b>MouseListener</b> responds to events that deal with clicking 
            or moving the mouse on or over a component.  Register components
            using the addMouseListener() method.
	<ul class="inner">
		<li><b>mouseClicked()</b> - occurs when the mouse is clicked
                    on a component.
		<li><b>mouseEntered()</b> and <b>mouseExited()</b> - these occur when
                    the mouse enters or exits a component's boundaries.
		<li><b>mousePressed()</b> and <b>mouseReleased()</b> - these occur
                    when the mouse button is pressed or released within a
                    component's boundaries.
	</ul>
	<li><b>MouseMotionListener</b> responds to events that deal with the 
            motion of the mouse.  Register components using the
            addMouseMotionListener() method.
	<ul class="inner">
		<li><b>mouseDragged()</b> - occurs when the mouse is dragged 
                    (cursor moves while holding the button down) within a
                    component's area.
		<li><b>mouseMoved()</b> - when the mouse is moved within a
                    component's area.
	</ul>
</ul>

<div class="highlight">Mouse events are divided into two categories because
the mouse motion events require a lot more overhead and resources than the
other mouse events.</div>

<p>For both listeners, all events have a MouseEvent parameter that 
    represents the mouse event object that was fired.  Some useful
    methods of this object are:</p>

<ul class="outer">
	<li><b>getClickCount()</b> - returns an int for number of times the
            mouse was clicked in this event.
	<li><b>getPoint()</b> - returns a Point object that represents the 
            point inside the component where the mouse was clicked.  A Point
            object (check documentation) is an object that models a point
            on a two-dimensional surface;  a Point object has an x and a y
            attribute respresenting the x and y coordinates of the point.
	<li><b>getX()</b> and <b>getY()</b> - returns integers for the x 
            position or y position of the point where the mouse was clicked
            inside the component.
	<li><b>getButton()</b> - returns an integer (MouseEvent.BUTTON1, 
            MouseEvent.BUTTON2, MouseEvent.BUTTON3) that indicates which
            mouse button was used in the event, if applicable.
</ul>

<p>There are new additions to newer versions of Java that you might like to 
    check out.  For example, you can now write code that responds to
    events from the mouse wheel.  Check the documentation to read more.</p>

<div class="highlight">If you have a program that is going to use listeners
    and events from both MouseListener and MouseMotionListener, you can use the
    javax.swing.event.<b>MouseInputListener</b> instead:  it contains all the
    event handler methods for both mouse listeners.  Just implement MouseInputListener
instead of MouseListener and MouseMotionListener, and register any components firing
mouse events using addMouseInputListener().</div>

<h4>Exercise</h4>

<ol>
	<li>Create a new interface with a blank label in the south area of the 
            main frame.  You don't need anything else.
	<li>Register the interface ("this") with the mouse listener 
            and the mouse motion listener (e.g. this.addMouseListener(this);)
	<li>Add all the mouse event methods to the program.
	<li>Write code for the mouseMoved() event that sets the label's
            text to <font face="Courier New">(x, y)</font> where x and y are
            the x and y coordinates from the MouseEvent object (see the MouseEvent
            methods above to a hint regarding how to get the coordinates of the mouse
            pointer).
	<li>Test your program:  Move the mouse on the screen and see how the
            text in the label changes.
	<li>Add two integer instance variables "x" and "y" to your GUI class.
	<li>Add some code to the the mouseClicked() event that displays something when
            you click the mouse anywhere on the screen:
	<ol type="a">
		<li>Store the x-coordinate from the MouseEvent into the x instance variable.
		<li>Store the y-coordinate from the MouseEvent into the  y instance variable.
		<li>Invoke the repaint() method (just type repaint();).
	</ol>
	<li>Add the public void paint(Graphics g) method and give it the following statement:
            <br /><font face="Courier New">g.fillOval(x, y, 10, 10);</font><br />
            (this will draw a 10 x 10 circle at coordinate x,y on your JFrame)
	<li>Recompile and run the program.  What happens when you click on a spot in
            the content pane?
</ol>

<a name="adapt"><h3>Using Adapter Classes</h3></a>

<p>When implementing the interfaces for listeners that contain more than one
    event handler method, programmers find it cumbersome to include
    the empty methods that aren't being used.  For example, if your
    program needs a MouseListener to respond to mouseClicked() events,
    you have to also include empty methods for mousePressed(), mouseReleased(),
    mouseExited(), and mouseEntered() or your program won't compile.
    Most programmers use Java's <b>adapter classes</b> to make event
    handling more convenient.</p>

<p>For every listener that has 2 or more methods, there is an adapter class.  
    For example, there's a KeyAdapter, MouseAdapter, and MouseMotionAdapter
    (there's also a MouseInputAdapter if you want methods from both mouse
    listener classes).  There's no ActionAdapter, because the ActionListener
    interface has only one abstract method (actionPerformed()).  Each
    adapter class contains the empty event handler methods for its
    corresponding listener class.  Instead of having your interface implement
    KeyListener, for example, you can instead create an instance of KeyAdapter
    and include only those key event handler methods you need.</p>

<p>Adapter classes are actually classes, not interfaces.  This means that
    instead of implementing them, you have to create an instance of the
    adapter class, and therefore change the way you design your event
    handler. Instead of implementing an interface, we now have to create a
    child of our adapter class and instantiate it in our constructor.
    The problem with having to write a separate class however, is that the
    event handler needs access to data in our program and the program's GUI
    components.</p>

Instead of creating a separate class in its own file, we can create a
<b>private inner class</b> to our program, and make this class a child
of our adapter class.  A private inner class is a class defined as private
whose code resides inside your program's class definition.  We usually
define inner classes at the bottom of your main class, right before the
brace that closes the main class definition:

<pre>public class CalculateLoan extends JFrame {
	
	//.. other stuff for the CalculateLoan class

	// this is an inner class:
	private class KeyHandler extends KeyAdapter {
		public void keyPressed(KeyEvent e) {
			// do whatever when a key is pressed
		}
	}
}</pre>

<p>We make the inner class private because we don't want any other class 
    outside this program to access it.  Note that the only time you can
    define a class as private is if it's an inner class.</p>

<div class="puzzle">You can read more about adapter and inner classes on
    pages 497 to 501 in your textbook.</div>

<p>Once you've created your inner class, you would instantiate an instance
    of this class as your event handler and then register your components:</p>

<pre>public class CalculateLoan extends JFrame {
	
	public CalculateLoan() {
		// ...
		KeyHandler kh = new KeyHandler();
		txtBalance.addKeyListener(kh);
		txtInterest.addKeyListener(kh);
	}
	public static void main(String[] args) {
		//...
	}

	// this is an inner class:
	private class KeyHandler extends KeyAdapter {
		public void keyPressed(KeyEvent e) {
			// do whatever when a key is pressed
		}
	}
}</pre>

<div class="puzzle">Inner classes are not always appropriate.  You should only 
    create an inner class when there is a very close relationship between the
    main class and the inner class, as there is in this example.  In fact,
    event handlers are one of the very few occasions where inner classes are
    acceptable.</div>

<p>Here is the code for our key handling example with an inner class that
    extends the KeyAdapter class:</p>

<p><i>NOTE: this is the hand-written code.  Obviously your code will
        look different if you're using Netbeans.</i></p>

<pre>import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class MoreEvents2 extends JFrame implements ActionListener
{
	private JTextField txtBalance = new JTextField(10);
	private JTextField txtRate = new JTextField(10);
	private JLabel lblInterest = new JLabel("", JLabel.RIGHT);
	private JButton cmdCalc = new JButton("Calculate");
	private JButton cmdExit = new JButton("Exit");

	public MoreEvents2() {
		super("More Events");
		
		KeyHandler kh = new KeyHandler();
		cmdCalc.addActionListener(this);
		cmdExit.addActionListener(this);
		txtBalance.addKeyListener(kh);
		txtRate.addKeyListener(kh);

		JPanel pnlFields = new JPanel(new GridLayout(0, 2));
		pnlFields.add(new JLabel("Balance:", JLabel.RIGHT));
		pnlFields.add(txtBalance);
		pnlFields.add(new JLabel("Rate:", JLabel.RIGHT));
		pnlFields.add(txtRate);
		pnlFields.add(new JLabel("Interest:", JLabel.RIGHT));
		pnlFields.add(lblInterest);

		JPanel pnlButtons = new JPanel(new GridLayout(1, 0));
		pnlButtons.add(cmdCalc);
		pnlButtons.add(cmdExit);

		JPanel pnlMain = new JPanel(new BorderLayout());
		pnlMain.add(pnlFields, BorderLayout.CENTER);
		pnlMain.add(pnlButtons, BorderLayout.SOUTH);

		Container c = this.getContentPane();
		c.setLayout(new FlowLayout());
		c.add(pnlMain);
	}
	
	public void actionPerformed(ActionEvent e) {
		if (e.getSource() == cmdCalc)
		{
			if (KtcUtils.isNumericFloat(txtBalance.getText()) &&
				KtcUtils.isNumericFloat(txtRate.getText()))
			{
				double balance = Double.parseDouble(txtBalance.getText());
				double rate = Double.parseDouble(txtRate.getText());
				double interest = balance * (rate/100);
				
				lblInterest.setText(String.format("%.2f", interest));
				txtBalance.setText("");
				txtRate.setText("");
				txtBalance.requestFocus();
			} else {
				JOptionPane.showMessageDialog(null, 
					"Is there a problem with one of your values?",
					"Error", JOptionPane.ERROR_MESSAGE);
			}
		} else if (e.getSource() == cmdExit)
		{
                        // using my own library here:
			if (KtcGuiUtils.exitOk())
				System.exit(0);
		}
	}

	private class KeyHandler extends KeyAdapter
	{
		public void keyTyped(KeyEvent e) {
			if (e.getSource() instanceof JTextField)
			{
				char key = e.getKeyChar();
				if (!Character.isDigit(key) && key != '.')
				{	
					e.setKeyChar('\0');
				}
			}
		}
	};
}</pre>

<script type="text/javascript" src="../scripts/copynote.js"></script>
</body>
</html>
