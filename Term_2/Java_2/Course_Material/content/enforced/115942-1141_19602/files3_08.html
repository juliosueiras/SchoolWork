<!doctype html public "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>File Input</title>
<script type="text/javascript" src="scripts/header.js"></script>
<link rel="stylesheet" type="text/css" href="css/prog.css">

<script type="text/javascript">
<!--
var q1 = "If the first index is 0 and the last index is 10, then the array has a length of 11 (the array has 11 elements).";
//-->
</script>

</head>

<body onload='window.focus()'>

<h2>File Input</h2>

<h3>Topics Covered:</h3>

<ul class="outer">
	<li><a href="#create">Reading Character Files</a>
	<li><a href="#primitives">Reading Primitive Data</a>
	<li><a href="#valid">Retrieving Valid Data</a>
	<li><a href="#ex">Exercise</a>
</ul>

<h3>Things To Do Before Reading This Section:</h3>
<ul class="outer">
	<li>Read chapter 9.7 in your textbook.
	<li>Try questions 9.25 to 9.30 on page 335 of your textbook.
        <li>Try programming questions 9.18 to 9.21 on pg. 339.
    <li>Read chapter 9.8 in your textbook.
</ul>

<h3>Things To Do After Reading This Section</h3>
<ul class="outer">
	<li>Read the <a href="http://www.java-tips.org/java-se-tips/java.util/scanning-text-with-java.util.scanner-3.html">Scanning Text with Scanner</a> article.
	<li>Read the <a href="http://java.sun.com/docs/books/tutorial/essential/regex/index.html">Regular Expressions Lesson</a> in the Java Tutorial.
	<li>Do any homework assigned by your professor.
</ul>

<!-- 
http://java.sun.com/developer/JDCTechTips/2004/tt1201.html
http://www.particle.kth.se/~lindsey/JavaCourse/Book/Part1/Java/Chapter09/scannerFile.html
http://www.kodejava.org/examples/241.html
http://www.javabeat.net/tips/2007/09/parsing-input-using-scanner/
http://java.sun.com/docs/books/tutorial/essential/io/scanning.html
 -->
<a name="read"><h3>Reading Character Files</h3></a>

<p>Reading data from a plain text file that was created with a character output
stream is as simple as following a similar 3-step process as you did when you
created the file:</p>

<ol>
	<li>Open an input stream from the file
	<li>Read and parse the records
	<li>Close the input stream
</ol>

<p>In Chapter 9.7, they describe how to read in data from a plain text file
using the Scanner class.  You've already used the Scanner class for keyboard
input:  When you construct a Scanner object you are giving the constructor
System.in.  System.in refers to the default input device (keyboard).  When
you give the Scanner constructor a String, that String value becomes the
input.  For example:</p>

<pre>Scanner scanner = new Scanner("this is a string 123 456");
while (scanner.hasNext())
	System.out.println(scanner.next());</pre>

<p>The above code will output:</p>

<pre>this
is
a
string
123
456</pre>

<p>The Scanner divides its input string into <b>tokens</b>, and each token is
<i>delimited</i> by whitespace.  In this case, the string has 6 tokens:
this, is, a, string, 123, and 456.  Each of the 6 tokens is separated by a
space.</p>

<p>The <i>scanner.hasNext()</i> method returns true if there is a token coming
up.  In the first iteration of the loop in the example above, scanner.hasNext()
returns true, because it sees the first token ("this").  The scanner.next()
method then retrieves and returns that token as a string, up to but not
including the space.  In the second iteration, the hasNext() method returns
true again, because it sees the second token ("is").  Again, the scanner.next()
method returns the string "is".  The loop continues until the last token "456"
is read.  When the loop condition scanner.hasNext() is checked the final time,
it returns false becauase there are no tokens left.</p>

<p>If your input data has more than one line (as your files likely will), you
can use the scanner.hasNextLine() and scanner.nextLine() instead of
scanner.hasNext() and scanner.next().  They work in the same manner, except
that the "next line" methods use the new-line as their default delimiter.</p>

<p>The default delimiter for tokens is the whitespace characters.  This includes
tabs, spaces, and new-lines.  You can change the default token delimter by
using the scanner's useDelimiter() method.  This is an overloaded method
with two versions.  One takes a string argument that represents the delimiter
you'd like to use.  The second version takes a Pattern object.  You can read
more about Pattern objects in
<a href="http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html">the Pattern docs</a> and in
<a href="http://leepoint.net/notes-java/data/strings/40regular_expressions/26pattern-matcher.html">this article</a>.  Either way, the
Scanner class supports regular expressions.  Examples:</p>

<pre>scanner.useDelimiter(",");      // a comma is the delimiter
scanner.useDelimiter("\\|");    // the pipe is the delimiter
scanner.useDelimiter(",|\\s");  // the comma or whitespace delimiter
// comma preceded or followed by some amount of whitespace
scanner.useDelimiter("\\s*,\\s*");  
scanner.useDelimiter("\n");    // newline delimiter
// a better way of getting the system's new-line character as the delimiter:
scanner.useDelimiter(System.getProperty("line.separator"));
// an even better way of catching all the possible values
// that could represent a newline:
scanner.useDelimiter("\r\n|[\r\n\u2028\u2029\u0085]");</pre>

<div class="puzzle">Note: <a href="http://www.leepoint.net/notes-java/io/10file/sys-indep-newline.html">System
Independent New-Line Characters</a>.</div>

<p>Having the ability to use tokens and different delimiters means that you can
use the Scanner class on a data file!  In fact, one of the Scanner constructors
accepts a File object!  For example, the following statements sets up a Scanner
object stream to the file "example.dat":</p>

<pre>// short way:
Scanner fileIn = new Scanner(new File("example.dat"));
// long way:
File file = new File("example.dat");
Scanner fileIn = new Scanner(file);</pre>

<p>For example, imagine a file that contained the following:</p>
<pre>Jollymore, Kaluha:  fat grey tabby
Widmann, Bridget: tiny but destructive grey tabby
MacDonald, Bibs: little black cat with OCD</pre>

<p>You could then use the following code snippet to display each line of the
file:</p>
<pre>Scanner scanner = new Scanner(new File("example.dat"));
while (scanner.hasNextLine());
   System.out.println(scanner.nextLine());
scanner.close();</pre>

<p>Alternatively, you could say:</p>
<pre>Scanner scanner = new Scanner(new File("example.dat"));
<font color="maroon">scanner.useDelimiter(System.getProperty("line.separator"));</font>
while (scanner.<font color="maroon">hasNext()</font>);
   System.out.println(scanner.<font color="maroon">next()</font>);
scanner.close();</pre>
<p>The output would basically just be the contents of the file (see above).</p>

<p><b>Don't forget to close your scanner object when you're done reading in all
the data!</b></p>

<p>When you construct a Scanner using a File object, a FileNotFoundException could
be thrown if the source file does not exist (you can't read from a file that
isn't there).  This is an unchecked exception (a child of the IOException
class) so make sure you handle this exception in some way.</p>

<p>If you like, you can even parse each line of input from the file using
additional delmiters.  For example, the file description for this file
indicates that the last name field value is followed by a comma, which is
then followed by the first name field value.  This is then followed by a
colon with precedes a description.  Therefore, there are two different
field delimiters:  the comma separating the names and the colon separating
the names from the description.  We can extract these three individual
fields using a few different techniques.</p>

<h4>Using String.split()</h4>

<p>The split() method in the String class will accept a regular expression
that defines the delimiter, split a string into an array of strings, and
return the array.  For example:</p>

<pre>String s = "cat, dog, fish, hamster, lizard".
String[] pets = s.split(",\\s*");</pre>

<p>The above statements will split the string s into a 5 element array
called pets.  pets[0] contains "cat", pets[1] contains "dog", pets[2]
contains "fish", pets[3] contains "hamster", and pets[4] contains "lizard".</p>

<p>We know that each record has three fields separated by a comma or colon,
so we could use the following to separate up the fields:</p>

<pre>Scanner scanner = new Scanner(new File("example.dat"));
scanner.useDelimiter(System.getProperty("line.separator"));
while (scanner.hasNext()) {
   String s = scanner.next();
   String[] fields = s.split("\\s*,\\s*|\\s*:\\s*");
   System.out.println("Cat Info:");
   for (String f : fields) {
      System.out.println(f);
   }
   System.out.println();
}
scanner.close();</pre>

<p>The above code segment will output:</p>

<pre>Cat Info:
Jollymore
Kaluha
fat grey tabby

Cat Info:
Widmann
Bridget
tiny but destructive grey tabby

Cat Info:
MacDonald
Bibs
little black cat with OCD</pre>

<h4>Using Additional Scanner Objects</h4>

<p>A second way of parsing a record is to use a second Scanner object.
The first scanner object retrieves a record, and the second object
retrieves the individual fields from each record.  Example:</p>

<pre>public static void main(String[] args) throws IOException {
   Scanner scanner = new Scanner(new File("example.dat"));
   scanner.useDelimiter(System.getProperty("line.separator"));
   while (scanner.hasNext()) {
     String s = scanner.next();
     displayFields(s);
   }
   scanner.close();
}
private static void displayFields(String s) {
   System.out.println("Cat Info:");
   Scanner fieldSep = new Scanner(s);
   fieldSep.useDelimiter("\\s*,\\s*|\\s*:\\s*");
   while (fieldSep.hasNext())
      System.out.println(fieldSep.next());
   System.out.println();
   fieldSep.close();
}</pre>

<p>It usually won't matter which way you chose to parse a record.  Sometimes
you'll prefer to use the split() method and sometimes you'll prefer to use
an additional Scanner object.  As long as you're familiar with regular
expressions, you should have no problem working with either one.  If you
need more help on regular expressions, check out the
<a href="http://java.sun.com/docs/books/tutorial/essential/regex/index.html">Regular
Expressions Lesson</a> in the Java Tutorial and
<a href="http://www.cs.armstrong.edu/liang/intro8e/javasupplement.html">Supplements</a>
from your textbook (select "Part III Java Supplements" in the left-hand menu,
then click and download "Supplement H").</p>

<a name="primitives"><h3>Reading Primitive Data</h3></a>

<p>You will occasionally need to read in primitive data such as integers and
doubles, and even characters and booleans from a data file.  You could easily
use a method like Double.parseDouble() or Integer.parseInt() on a field value
after you retrieve it.  As an example, imagine you had a file with the
following description:</p>

<table border=1><tr><td colspan=3><b>File Name:</b> cds.dat</td></tr>
<tr><td colspan="3">A list of my CD inventory</td></tr>
<tr><th>Field Description</th><th>Data Type</th><th>Comments</th></tr>
<tr><td>cd title</td><td>String</td><td>the title of the CD</td></tr>
<tr><td>artist</td><td>String</td><td>the artist performing on the CD</td></tr>
<tr><td>number of copies</td><td>integer</td><td>the number of copies in inventory</td><tr>
<tr><td>cost</td><td>double</td><td>the cost value of this CD</td></tr>
</table>

<p>As an example, the file's contents are:</p>
<pre>Four Seasons, Vivaldi, 3, 12.99
Weight, Henry Rollins, 10, 10.00
Has Been, William Shatner, 9, 15.99
Hit and Run, Big Sugar, 12, 16.99</pre>

<p>A program reads in each CD record and displays the title and artist on one
line, and then the number of copies, cost, and the total value of this
inventory item (number of copies * cost) on the next line.  Each record will
be displayed in the following format:</p>

<pre>Sample Title by Sample Artist
x @ pp.pp ea:  $tt.tt</pre>
<p>(x is the number of copies, pp.pp is the cost, and tt.tt is the total value)</p>

<p>Code for this program might appear as:</p>

<pre>private static void main(String[] args) throws IOException {
  Scanner scanner = new Scanner(new File("cds.dat"));
  scanner.useDelimiter(System.getProperty("line.separator"));
  while (scanner.hasNext()) {
    String s = scanner.next();
    parseRecord(s);
  }
  scanner.close();
}

private static void parseRecord(String record) {
  Scanner recIn = new Scanner(record);
  recIn.useDelimiter("\\s*,\\s*");
	
  <font color="maroon">String title = recIn.next();
  String artist = recIn.next();
  int numCopies = Integer.parseInt(recIn.next());
  double price = Double.parseDouble(recIn.next());</font>
	
  double total = price * numCopies;
	
  System.out.println(title + " by " + artist);
  System.out.print(numCopies + " @ " + price + " ea.");
  System.out.printf(": $%3.2f%n", total);
	
  recIn.close();
}</pre>
	
<p>In the parseRecord() method above, we use the next() method to retrieve
the next token in the record string.  When we retrieve the number of copies
and the price, we parse those field values into int and double, respectively.</p>

<p>There is a much easier way to retrieve primitive data from a file using
Scanner.  When you've used Scanner for keyboard input, you used the nextInt()
and nextDouble() methods to retrieve integer and floating point values.
You can also use these to retrieve the values from the file in the above
example:</p>

<pre>...
String title = recIn.next();
String artist = recIn.next();
int numCopies = recIn.nextInt();
double price = recIn.nextDouble();
...</pre>

<p>This is definitely a lot easier than using parseInt() and parseDouble()!</p>

<a name="valid"><h3>Retrieving Valid Data</h3></a>

<p>When retrieving data from a file, it's always important to think of data
validation.  Is there any guarantee that the data you are reading is valid
data?  For example, what if you assume that the integer field you are about
to read in is a valid integer?  How do you know that the person who wrote
the output program that created the file did it correctly?  It's important
to ensure that your program doesn't crash or work abnormally when the input
data is invalid. There are a number of ways you can go about ensuring that
your program works properly; here are a couple of ideas to get you started.</p>

<h4>Using If-Statments</h4>

<p>The obvious way to check your data for validity is to use if-statements.
As you read in a field, you can check to see if it matches a given criteria.
For example, you could have something such as:</p>

<pre>String field = scanner.next();
int intField = 0;
if (isValidInt(field))
   intField = Integer.parseInt(field);
	 
private static boolean isValidInt(String s) {
   boolean ok = true;
   try {
      int temp = Integer.parseInt(s);
   } catch (NumberFormatException ex) {
      ok = false;
   }
   return ok;
}</pre>			

<h4>Checking for InputMismatchException</h4>

<p>In your past experience with Scanner, you learned that an
InputMismatchException is thrown if the user types a string when you
ask for an integer.  You can use this when reading data from a file,
as in the example below:</p>

<pre>try {
   ...
   int intField = scanner.nextInt();
	 ...
} catch (InputMismatchException ex) {
   // error message, or whatever
}</pre>

<h4>Using hasXXX() Methods</h4>

<p>This is probably the technique most preferred by programmers that
use the Scanner class.  It has the most flexibility and can sometimes
result in the least amount of code ;)</p>

<p>The Scanner class contains a set of methods that check to see if the
next token of a certain type exists.  These methods return true if the
token exists and false if the token doesn't exist.  For example, the
Scanner.hasInt() method returns true if the next token is a valid integer,
and the Scanner.hasDouble() method returns true if the next token is a
valid double value.</p>

<p>For example, given a file temp.dat with the contents:</p>

<pre>Kaluha Jollymore, 1992, 29.5</pre>

<p>The following statements hasXXX() methods below will result true or false:</p>

<pre>Scanner scanner = new Scanner(new File("temp.dat"));
scanner.useDelimiter("\\s*,\\s*");
System.out.println(scanner.hasNext());      // prints true
System.out.println(scanner.next());         // prints Kaluha Jollymore
System.out.println(scanner.hasNextInt());   // prints true
System.out.println(scanner.next());         // prints 1992
System.out.println(scanner.hasNextInt());   // prints false
System.out.println(scanner.next());         // prints 29.5</pre>

<p>The output of the last hasNextInt() statement is false because the third token is
29.5, and that is not a valid integer value.</p>

<p>It is standard when you use the Scanner class to read primitives from
a character file, that you use a statements such as:</p>

<pre>String title = (recIn.hasNext()) ? recIn.next() : "";
String artist = (recIn.hasNext()) ? recIn.next() : "";
int numCopies = (recIn.hasNextInt()) ? recIn.nextInt() : 0;
double price = (recIn.hasNextDouble()) ? recIn.nextDouble() : 0;</pre>

<p>In each of these, the conditional operator is used to check to see
if a valid token exists.  If the token does exist, the token is retrieved
and stored in the variable.  If the token does not exist, the default
null value is stored in the variable, instead.</p>

<a name="ex"><h4>Exercises</h4></a>

<p>The grades program:  In the previous session you created a program that
obtained information from the user about various assignments in different
courses.  For this exercise, write a program that reads and processes each
record.  After reading each record, calculate the percentage weighting of
that assignment towards the final grade (e.g. if the evaluation was 11/15,
and worth 10% of your grade, that should give you a total percentage of
11/15 * 10 = 7.33% of your final grade).
After all records have been read, calculate and
display the total grade percentage to date for all your
stored assignment records.</p>

<p><b>Example:</b></p>

<p>Sample file data:</p>

<!--<pre>prog10082|Assignment 1|14|15|5
prog10082|Assignment 2|20|25|10
prog10082|Mid Term Exam 1|50|55|20
prog10082|Mid Term Exam 2|53|55|20
prog10082|Assignment 3|22|25|10
prog10082|Final Exam|65|60|35</pre> -->


<pre>prog24178|Lab 1|9|10|2
prog24178|Lab 2|15|15|3
prog24178|Lab 3|14|15|3
prog24178|Mid Term|70|75|30</pre>

<p>Sample results:</p>

<!--Course			Eval.Title           Percent
----------------------------------------------------------
prog24178		Lab 1                 90.00%
prog24178		Lab 2                100.00%
prog24178		Lab 3                 93.33%
prog24178		Mid Term              93.33%

Average:                                      94.17%</pre>-->

<p><img src="images/fileInputGui1.png" /></p>
<p><i>HINT: to get the columns lined up, use String.format() and set
the text area's font to Courier or Courier New.</i></p>

<p><b>Challenge!</b></p>

<p>If you're looking for a challenge, try this:</p>
<p><img src="images/fileInputGui2a.png" /> 
<img src="images/fileInputGui2b.png" /></p>

<p>Here, I've added a combo box that allows the user to select
which course data they'd like to view, in case there is data for
more than one course in the data file.  I had to add a method
to my constructor that loaded the combo box with the course codes
that appear in the file (NOTE: a course code can appear more than
once in the course file so you only add a course code to the
combo box if it's not already in there.  Ask me for hints on 
how to do this with the least code possible ;) )</p>

<p>When the user selects a course and then clicks the List button,
They see only the data for the course they selected.  Try to
make good use of methods here (I used a couple of overloaded
methods I created) so you don't end up with too much redundant
code.</p>



<script language="JavaScript" type="text/javascript" src="../scripts/copynote.js"></script>


</body>
</html>
